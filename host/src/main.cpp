/**
 * @file main.cpp
 * @brief Main application entry point for moonmic-host
 */

#include "config.h"
#include "audio_receiver.h"
#include "sunshine_integration.h"
#include "display_manager.h"
#include "sunshine_settings_gui.h"
#include "sunshine_webui.h"
#include "display_settings_gui.h"
#include "single_instance.h"
#include "version_checker.h"
#include "debug_gui.h"
#include "gui_helper.h"
#include "version.h"  // Auto-generated by CMake
#include <iostream>
#include <csignal>
#include <thread>
#include <chrono>

#ifdef _WIN32
#include "platform/windows/driver_installer.h"
#include "platform/windows/audio_utils.h"
#include "platform/windows/audio_device_manager.h"
#include "guardian_launcher.h"
#endif

#ifdef USE_IMGUI
#include <imgui.h>
#include <imgui_impl_glfw.h>
#include <imgui_impl_opengl3.h>
#include <GLFW/glfw3.h>

// STB Image for loading window icon
#define STB_IMAGE_IMPLEMENTATION
#include "platform/windows/stb_image.h"
#endif

using namespace moonmic;

static bool g_running = true;
static AudioReceiver* g_receiver = nullptr;
// Global debug flag (verbose logging) - non-static for external linkage
bool g_debug_mode = false;

#ifdef USE_IMGUI
// Version update checker state
static bool g_update_available = false;
static bool g_update_check_done = false;
static bool g_update_dismissed = false;
static std::string g_latest_version;
static std::string g_download_url;
#endif

void signal_handler(int signal) {
    std::cout << "\n[Main] Shutting down..." << std::endl;
    g_running = false;
    
    // Ensure the receiver is stopped to restore original microphone
    if (g_receiver) {
        g_receiver->stop();
    }
}

#ifdef USE_IMGUI

void renderGUI(GLFWwindow* window, AudioReceiver& receiver, SunshineIntegration& sunshine, 
               SunshineWebUI& sunshine_webui, DisplayManager& display_mgr, 
               DisplaySettingsGUI& display_settings_gui, SunshineSettingsGUI& sunshine_settings_gui,
               DebugGUI& debug_gui, Config& config) {
    // Use full viewport size for main window
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(viewport->WorkPos);
    ImGui::SetNextWindowSize(viewport->Size);
    
    ImGuiWindowFlags window_flags = 0;
    window_flags |= ImGuiWindowFlags_NoTitleBar;
    window_flags |= ImGuiWindowFlags_NoCollapse;
    window_flags |= ImGuiWindowFlags_NoMove;
    window_flags |= ImGuiWindowFlags_NoNavFocus;
    // Note: NoBringToFrontOnFocus removed to allow debug window to appear on top
    
    ImGui::Begin("MoonMic Host", nullptr, window_flags);
    
    // Title with About button on the right
    ImGui::Text("MoonMic host by AorsiniYT - v%s", MOONMIC_VERSION);
    ImGui::SameLine(ImGui::GetWindowWidth() - 80);  // Position to the right
    if (ImGui::SmallButton("About")) {
        ImGui::OpenPopup("About MoonMic");
    }
    ImGui::Separator();
    
#ifdef _WIN32
    // === Driver Management Section ===
    ImGui::Text("Virtual Audio Driver");
    
    static bool show_driver_manager = false;
    DriverInstaller installer;
    
    // Driver selection (VB-Cable vs Steam)
    static int selected_driver = 0; // 0 = VB-Cable, 1 = Steam Streaming Microphone (WDM-KS)
    const char* driver_names[] = { "VB-CABLE", "Steam Streaming Microphone (WDM-KS)" };
    
    // Auto-detect which driver is selected based on config
    if (config.audio.driver_device_name.find("VB-Audio") != std::string::npos) {
        selected_driver = 0;
    } else if (config.audio.driver_device_name.find("Steam") != std::string::npos || 
               config.audio.recording_endpoint_name.find("Steam") != std::string::npos) {
        selected_driver = 1;
    }
    
    ImGui::Text("Driver Type:");
    ImGui::SameLine();
    if (ImGui::Combo("##DriverType", &selected_driver, driver_names, IM_ARRAYSIZE(driver_names))) {
        // Update config based on selection
        if (selected_driver == 0) {
            config.audio.driver_device_name = "VB-Audio Virtual Cable";
            config.audio.recording_endpoint_name = "CABLE Output";
        } else {
            // CRITICAL: Use "Steam Streaming Microphone" not "Speakers"
            // The Microphone is the CAPTURE device where we inject audio
            // The Speakers is the PLAYBACK device (not what we need)
            config.audio.driver_device_name = "Steam Streaming Microphone";
            config.audio.recording_endpoint_name = "Steam Streaming Microphone";
        }
        
        // Auto-save
        std::string config_path = Config::getDefaultConfigPath();
        if (config.save(config_path)) {
            std::cout << "[Config] Auto-saved driver selection: " << config.audio.driver_device_name << std::endl;
        }
        
        // CRITICAL: Restart receiver with new device configuration
        if (receiver.isRunning()) {
            std::cout << "[Main] Switching to " << driver_names[selected_driver] << ", restarting receiver..." << std::endl;
            receiver.stop();
            
            // Brief pause to ensure clean shutdown
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            if (receiver.start(config)) {
                std::cout << "[Main] Receiver restarted successfully with new driver" << std::endl;
            } else {
                std::cerr << "[Main] Failed to restart receiver with new driver" << std::endl;
            }
        }
    }
    
    // Check driver installation status
    bool driver_installed = false;
    if (selected_driver == 0) {
        driver_installed = installer.isVBCableInstalled();
    } else {
        driver_installed = installer.isSteamSpeakersInstalled();
    }
    
    // Show driver status
    if (driver_installed) {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "[OK] %s Installed", driver_names[selected_driver]);
        
        if (selected_driver == 0) {
            std::string input_device = installer.getVBCableInputDevice();
            std::string output_device = installer.getVBCableOutputDevice();
            if (!input_device.empty()) {
                ImGui::Text("  Input: %s", input_device.c_str());
            }
            if (!output_device.empty()) {
                ImGui::Text("  Output: %s", output_device.c_str());
            }
        }
    } else {
        ImGui::TextColored(ImVec4(1, 0.5, 0, 1), "[!] %s Not Installed", driver_names[selected_driver]);
        ImGui::TextWrapped("Virtual audio driver is required for audio routing.");
    }
    
    ImGui::Spacing();
    
    // Driver Manager button (ALWAYS VISIBLE)
    if (ImGui::Button("Driver Manager", ImVec2(150, 30))) {
        show_driver_manager = true;
    }
    
    ImGui::SameLine();
    
    // Quick install button if driver not installed
    if (!driver_installed) {
        if (ImGui::Button("Quick Install", ImVec2(150, 30))) {
            if (!DriverInstaller::isRunningAsAdmin()) {
                ImGui::OpenPopup("Need Admin");
            } else {
                bool success = false;
                if (selected_driver == 0) {
                    success = installer.installVBCable();
                } else {
                    success = installer.installSteamSpeakers();
                }
                
                if (success) {
                    ImGui::OpenPopup("Install Success");
                } else {
                    ImGui::OpenPopup("Install Failed");
                }
            }
        }
    }
    
    // Driver Manager Window
    if (show_driver_manager) {
        ImGui::SetNextWindowSize(ImVec2(500, 450), ImGuiCond_FirstUseEver); // Increased height
        if (ImGui::Begin("Driver Manager", &show_driver_manager)) {
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 1.0f, 1.0f), "Virtual Audio Driver Configuration");
            ImGui::Separator();
            ImGui::Spacing();
            
            // --- Steam Streaming Speakers Section ---
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.5f, 1.0f), "Steam Streaming Microphone (Recommended)");
            bool steam_installed = installer.isSteamSpeakersInstalled();
            
            if (steam_installed) {
                ImGui::TextColored(ImVec4(0, 1, 0, 1), "Status: Installed");
                ImGui::TextWrapped("Ready for low-latency WDM-KS audio.");
                
                ImGui::Spacing();
                if (ImGui::Button("Uninstall Steam Driver", ImVec2(200, 25))) {
                    if (!DriverInstaller::isRunningAsAdmin()) {
                        ImGui::OpenPopup("Need Admin");
                    } else {
                        // Stop audio receiver to release driver before uninstalling
                        receiver.stop();
                        std::cout << "[Main] Stopped audio receiver for driver uninstall" << std::endl;
                        
                         if (installer.uninstallSteamSpeakers()) {
                            ImGui::OpenPopup("Uninstall Success");
                        } else {
                            ImGui::OpenPopup("Uninstall Failed");
                        }
                    }
                }
            } else {
                ImGui::TextColored(ImVec4(1, 0.5, 0, 1), "Status: Not Installed");
                if (ImGui::Button("Install Steam Driver", ImVec2(200, 25))) {
                    if (!DriverInstaller::isRunningAsAdmin()) {
                        ImGui::OpenPopup("Need Admin");
                    } else {
                        if (installer.installSteamSpeakers()) {
                            ImGui::OpenPopup("Install Success");
                        } else {
                            ImGui::OpenPopup("Install Failed");
                        }
                    }
                }
            }
            
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();

            // --- VB-CABLE Section ---
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.5f, 1.0f), "VB-CABLE Driver (Alternative)");
            bool vb_installed = installer.isVBCableInstalled();
            
            if (vb_installed) {
                ImGui::TextColored(ImVec4(0, 1, 0, 1), "Status: Installed");
                std::string input = installer.getVBCableInputDevice();
                std::string output = installer.getVBCableOutputDevice();
                if (!input.empty()) ImGui::Text("  Input: %s", input.c_str());
                if (!output.empty()) ImGui::Text("  Output: %s", output.c_str());
                
                ImGui::Spacing();
                if (ImGui::Button("Uninstall VB-CABLE", ImVec2(200, 25))) {
                    if (!DriverInstaller::isRunningAsAdmin()) {
                        ImGui::OpenPopup("Need Admin");
                    } else {
                        // Stop audio receiver to release driver before uninstalling
                        receiver.stop();
                        std::cout << "[Main] Stopped audio receiver for driver uninstall" << std::endl;
                        
                        // VBCable uninstall usually runs the setup with different params or relies on user
                        if (installer.uninstallVBCable()) {
                             ImGui::OpenPopup("Uninstall Started");
                        } else {
                             ImGui::OpenPopup("Uninstall Failed");
                        }
                    }
                }
            } else {
                ImGui::TextColored(ImVec4(1, 0.5, 0, 1), "Status: Not Installed");
                if (ImGui::Button("Install VB-CABLE", ImVec2(200, 25))) {
                    if (!DriverInstaller::isRunningAsAdmin()) {
                        ImGui::OpenPopup("Need Admin");
                    } else {
                        if (installer.installVBCable()) {
                            ImGui::OpenPopup("Install Success");
                        } else {
                            ImGui::OpenPopup("Install Failed");
                        }
                    }
                }
            }
            
            ImGui::Spacing();
            ImGui::Separator();
            ImGui::Spacing();
            
            ImGui::TextWrapped("Note: Administrator privileges are required for driver operations.");
            
            ImGui::Spacing();
            if (ImGui::Button("Close", ImVec2(100, 25))) {
                show_driver_manager = false;
            }
        }
        ImGui::End();
    }
    
    // --- Popups ---

    // Initial Setup Wizard Logic (Auto-open if no driver)
    static bool initial_setup_checked = false;
    static bool show_initial_setup = false;
    
    if (!initial_setup_checked) {
        if (!installer.isAnyDriverInstalled()) {
            show_initial_setup = true;
            ImGui::OpenPopup("Initial Setup Wizard");
        }
        initial_setup_checked = true;
    }

    if (ImGui::BeginPopupModal("Initial Setup Wizard", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::TextColored(ImVec4(0.3f, 0.8f, 1.0f, 1.0f), "Welcome to MoonMic!");
        ImGui::Separator();
        ImGui::Text("No virtual audio driver was detected on your system.");
        ImGui::Text("You need at least one driver to route audio correctly.");
        ImGui::Spacing();
        
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Recommended: Steam Streaming Microphone");
        ImGui::TextWrapped("Provides lower latency and better stability via WDM-KS.");
        
        ImGui::Spacing();
        
        if (ImGui::Button("Install Steam Driver (Recommended)", ImVec2(300, 40))) {
             if (!DriverInstaller::isRunningAsAdmin()) {
                ImGui::OpenPopup("Need Admin"); // Nested popup might be tricky, better to just show text or close this one
             } else {
                 if (installer.installSteamSpeakers()) {
                     ImGui::CloseCurrentPopup();
                     ImGui::OpenPopup("Install Success");
                 } else {
                     ImGui::OpenPopup("Install Failed");
                 }
             }
        }
        
        ImGui::Spacing();
        ImGui::Text("Alternative: VB-CABLE");
        
        if (ImGui::Button("Install VB-CABLE", ImVec2(300, 30))) {
             if (!DriverInstaller::isRunningAsAdmin()) {
                ImGui::OpenPopup("Need Admin");
             } else {
                 if (installer.installVBCable()) {
                     ImGui::CloseCurrentPopup();
                     ImGui::OpenPopup("Install Success");
                 } else {
                     ImGui::OpenPopup("Install Failed");
                 }
             }
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        
        if (ImGui::Button("Skip for now", ImVec2(120, 30))) {
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    // Admin privileges popup
    if (ImGui::BeginPopupModal("Need Admin", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Administrator privileges required.");
        ImGui::Text("The application will restart with admin rights.");
        ImGui::Separator();
        
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            if (DriverInstaller::restartAsAdmin()) {
                // Successfully restarted as admin, exit this instance
                std::cout << "[Main] Restarting as admin, closing current instance..." << std::endl;
                glfwSetWindowShouldClose(window, GLFW_TRUE);
            }
            ImGui::CloseCurrentPopup();
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
    
    // Installation success popup
    if (ImGui::BeginPopupModal("Install Success", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Driver installed successfully!");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        ImGui::TextWrapped("A system reboot is required for the driver to take effect.");
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Do you want to restart now?");
        ImGui::Spacing();
        
        if (ImGui::Button("Reboot Now", ImVec2(120, 0))) {
            #ifdef _WIN32
            system("shutdown /r /t 5 /c \"Rebooting to complete driver installation...\"");
            #endif
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::SameLine();
        
        if (ImGui::Button("Later", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    // Installation failed popup
    if (ImGui::BeginPopupModal("Install Failed", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Failed to install driver.");
        ImGui::Text("Please check the console for error details.");
        ImGui::Separator();
        
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
    
    ImGui::Separator();
#endif
    
    // Sunshine Integration
    ImGui::Text("Sunshine Integration");
    
    if (sunshine.isPaired()) {
        // Sunshine is paired
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "[OK] Sunshine Paired");
        
        // Show Web UI login status
        if (sunshine_webui.isLoggedIn()) {
            ImGui::Text("Web UI: Logged in as %s", config.sunshine.webui_username.c_str());
            
            // Sunshine Settings button
            if (ImGui::Button("Sunshine Settings")) {
                sunshine_settings_gui.open();
            }
        } else {
            // Paired but not logged in
            ImGui::TextColored(ImVec4(1, 1, 0, 1), "Web UI: Not logged in");
            ImGui::TextWrapped("Login required for client validation & security");
            
            if (ImGui::Button("Login to Sunshine Web UI")) {
                ImGui::OpenPopup("Sunshine Web UI Login");
            }
            
            // Web UI login modal
            ImVec2 center = ImGui::GetMainViewport()->GetCenter();
            ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
            
            if (ImGui::BeginPopupModal("Sunshine Web UI Login", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
                ImGui::Text("Login to Sunshine Web UI");
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                static char webui_username[128] = "";
                static char webui_password[128] = "";
                static std::string login_error = "";
                
                ImGui::InputText("Username", webui_username, sizeof(webui_username));
                ImGui::InputText("Password", webui_password, sizeof(webui_password), ImGuiInputTextFlags_Password);
                
                if (!login_error.empty()) {
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1, 0, 0, 1), "%s", login_error.c_str());
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                if (ImGui::Button("Login", ImVec2(120, 0))) {
                    if (sunshine_webui.login(webui_username, webui_password)) {
                        login_error = "";
                        memset(webui_password, 0, sizeof(webui_password));
                        ImGui::CloseCurrentPopup();
                    } else {
                        login_error = "Invalid Sunshine credentials";
                    }
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Cancel", ImVec2(120, 0))) {
                    login_error = "";
                    ImGui::CloseCurrentPopup();
                }
                
                ImGui::EndPopup();
            }
        }
    } else {
        // NOTE: PIN-based pairing is currently DISABLED
        // Sunshine Web UI login provides more permissions and is the preferred method
        // PIN pairing code is preserved below for potential future reuse
        
        // Show message that Web UI login is required instead
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "[!] Sunshine Web UI Login Required");
        ImGui::TextWrapped("Please login to Sunshine Web UI to access full functionality.");
        ImGui::Spacing();
        if (ImGui::Button("Login to Sunshine Web UI")) {
            ImGui::OpenPopup("Sunshine Web UI Login");
        }
    }
    
    // Web UI Login Modal (outside if/else so it's accessible from both paths)
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    
    if (ImGui::BeginPopupModal("Sunshine Web UI Login", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Login to Sunshine Web UI");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        static char webui_username[128] = "";
        static char webui_password[128] = "";
        static std::string login_error = "";
        
        ImGui::InputText("Username", webui_username, sizeof(webui_username));
        ImGui::InputText("Password", webui_password, sizeof(webui_password), ImGuiInputTextFlags_Password);
        
        if (!login_error.empty()) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(1, 0, 0, 1), "%s", login_error.c_str());
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        if (ImGui::Button("Login", ImVec2(120, 0))) {
            if (sunshine_webui.login(webui_username, webui_password)) {
                login_error = "";
                memset(webui_password, 0, sizeof(webui_password));
                ImGui::CloseCurrentPopup();
            } else {
                login_error = "Invalid Sunshine credentials";
            }
        }
        
        ImGui::SameLine();
        
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            login_error = "";
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    ImGui::Separator();
    
    // Status Indicators (simplified - LEDs instead of detailed stats)
    auto stats = receiver.getStats();
    bool connected = stats.is_connected;
    bool receiving = stats.is_receiving;
    bool paused = stats.is_paused;
    
    ImGui::Text("Status");
    debug_gui.drawStatusIndicators(connected, receiving, paused);
    
    // Show client info if connected
    if (connected) {
        ImGui::SameLine(ImGui::GetWindowWidth() - 200);
        if (!stats.client_name.empty()) {
            ImGui::TextColored(ImVec4(0.5f, 0.8f, 1.0f, 1.0f), "%s", stats.client_name.c_str());
        } else {
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "%s", stats.last_sender_ip.c_str());
        }
    }
    
    ImGui::Separator();
    
    // Configuration (editable)
    ImGui::Text("Configuration");
    
    bool config_changed = false;
    
    // Port input
    int prev_port = config.server.port;
    if (ImGui::InputInt("Port", &config.server.port, 0, 0)) {
        if (config.server.port < 1 || config.server.port > 65535) {
            config.server.port = prev_port;  // Revert invalid value
        } else if (config.server.port != prev_port) {
            config_changed = true;
        }
    }
    
    // Sample rate is now auto-detected from the audio device
    // No manual override needed - system uses device's native rate
    
    // Channels input
    int prev_channels = config.audio.channels;
    if (ImGui::InputInt("Channels", &config.audio.channels, 0, 0)) {
        if (config.audio.channels < 1 || config.audio.channels > 2) {
            config.audio.channels = prev_channels;  // Revert invalid value
        } else if (config.audio.channels != prev_channels) {
            config_changed = true;
        }
    }
    
    // Auto-save if any config changed
    if (config_changed) {
        std::string config_path = Config::getDefaultConfigPath();
        if (config.save(config_path)) {
            std::cout << "[Config] Auto-saved configuration changes" << std::endl;
        }
    }
    
    // Whitelist checkbox with auto-save
    bool prev_whitelist = config.security.enable_whitelist;
    if (ImGui::Checkbox("Whitelist Enabled", &config.security.enable_whitelist)) {
        if (prev_whitelist != config.security.enable_whitelist) {
            // Configuration changed, auto-save
            std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                std::cout << "[Config] Auto-saved changes" << std::endl;
            }
        }
    }
    
    // Speaker Mode checkbox (for debugging)
    bool prev_speaker = config.audio.use_speaker_mode;
    if (ImGui::Checkbox("Speaker Mode (Debug)", &config.audio.use_speaker_mode)) {
        if (prev_speaker != config.audio.use_speaker_mode) {
            // Hot-swap audio output if receiver is running
            if (receiver.isRunning()) {
                receiver.switchAudioOutput(config.audio.use_speaker_mode);
            }
            
            std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                std::cout << "[Config] Auto-saved speaker mode: " 
                          << (config.audio.use_speaker_mode ? "ON (direct playback)" : "OFF (VB-Cable)") 
                          << std::endl;
            }
        }
    }
    if (config.audio.use_speaker_mode) {
        ImGui::TextColored(ImVec4(1, 0.8f, 0, 1), "Warning: Audio goes to speakers, NOT VB-Cable");
    } else {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Audio sent to VB-Cable (normal mode)");
    }
    
    // ==========================================
    // Microphone Settings (Windows only)
    // ==========================================
#ifdef _WIN32
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    if (ImGui::CollapsingHeader("Microphone Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
        static AudioDeviceManager deviceManager;
        static std::vector<AudioDeviceInfo> availableMics;
        static int selectedMicIndex = -1;
        static bool micsLoaded = false;
        
        // Load microphones on first render
        if (!micsLoaded) {
            availableMics = deviceManager.enumerateRecordingDevices();
            micsLoaded = true;
            
            // Find index of current original_mic_id
            if (!config.audio.original_mic_id.empty()) {
                for (size_t i = 0; i < availableMics.size(); i++) {
                    if (availableMics[i].id == config.audio.original_mic_id) {
                        selectedMicIndex = static_cast<int>(i);
                        break;
                    }
                }
            }
        }
        
        // Show current default microphone
        ImGui::Text("Current Default Microphone:");
        ShowHelpTooltip(Tooltips::CURRENT_DEFAULT_MIC);
        
        AudioDeviceInfo currentDefault = deviceManager.getCurrentDefaultRecordingDevice();
        if (!currentDefault.id.empty()) {
            ImVec4 color = currentDefault.is_virtual ? ImVec4(1, 0.5f, 0, 1) : ImVec4(0, 1, 0, 1);
            ImGui::TextColored(color, "  %s", currentDefault.name.c_str());
            if (currentDefault.is_virtual) {
                ImGui::SameLine();
                ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "(Virtual)");
            }
        } else {
            ImGui::TextColored(ImVec4(1, 0, 0, 1), "  [No default microphone]");
        }
        
        ImGui::Spacing();
        
        // Original/Restore Microphone selector
        ImGui::Text("Microphone to Restore on Exit:");
        ShowHelpTooltip(Tooltips::ORIGINAL_MIC_SELECTOR);
        
        // Refresh button
        ImGui::SameLine();
        if (ImGui::SmallButton("Refresh")) {
            availableMics = deviceManager.enumerateRecordingDevices();
            // Re-find selected index
            selectedMicIndex = -1;
            if (!config.audio.original_mic_id.empty()) {
                for (size_t i = 0; i < availableMics.size(); i++) {
                    if (availableMics[i].id == config.audio.original_mic_id) {
                        selectedMicIndex = static_cast<int>(i);
                        break;
                    }
                }
            }
        }
        
        // Dropdown selector
        if (availableMics.empty()) {
            ImGui::TextColored(ImVec4(1, 0, 0, 1), "No microphones detected");
        } else {
            std::string preview = selectedMicIndex >= 0 && selectedMicIndex < availableMics.size()
                ? availableMics[selectedMicIndex].name
                : "[Not Set]";
            
            if (ImGui::BeginCombo("##OriginalMic", preview.c_str())) {
                for (size_t i = 0; i < availableMics.size(); i++) {
                    // Skip virtual mics from the list
                    if (availableMics[i].is_virtual) continue;
                    
                    bool is_selected = (selectedMicIndex == static_cast<int>(i));
                    if (ImGui::Selectable(availableMics[i].name.c_str(), is_selected)) {
                        selectedMicIndex = static_cast<int>(i);
                        config.audio.original_mic_id = availableMics[i].id;
                        
                        // Save config
                        std::string config_path = Config::getDefaultConfigPath();
                        if (config.save(config_path)) {
                            std::cout << "[Config] Original microphone set to: " 
                                      << availableMics[i].name << std::endl;
                        }
                    }
                    
                    if (is_selected) {
                        ImGui::SetItemDefaultFocus();
                    }
                }
                ImGui::EndCombo();
            }
            
            // Show info about selected mic
            if (selectedMicIndex >= 0 && selectedMicIndex < availableMics.size()) {
                ImGui::TextColored(ImVec4(0, 1, 0, 1), 
                                   "✓ This microphone will be restored when app closes");
            } else {
                ImGui::TextColored(ImVec4(1, 1, 0, 1), 
                                   "⚠ No restore microphone set");
            }
        }
        
        ImGui::Spacing();
        
        // Guardian status
        bool guardianActive = GuardianLauncher::isGuardianRunning();
        ImGui::Text("Guardian Watchdog:");
        ShowHelpTooltip(Tooltips::GUARDIAN_STATUS);
        ImGui::SameLine();
        if (guardianActive) {
            ImGui::TextColored(ImVec4(0, 1, 0, 1), "Active");
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "(Monitoring for crashes)");
        } else {
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "Inactive");
        }
    }
#endif
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    // Debug Mode checkbox
    if (ImGui::Checkbox("Debug Mode (Verbose Logs)", &g_debug_mode)) {
        std::cout << "[Main] Debug mode: " << (g_debug_mode ? "ON" : "OFF") << std::endl;
        // Toggle console visibility with debug mode
        DebugGUI::showConsole(g_debug_mode);
    }
    ImGui::SameLine();
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "Shows console & detailed logs");
    
    // Performance Monitor button (only visible in debug mode)
    if (g_debug_mode) {
        if (ImGui::Button("Performance Monitor")) {
            debug_gui.toggle();
        }
        if (debug_gui.isVisible()) {
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.3f, 1), "[OPEN]");
        }
    }
    
    ImGui::Separator();
    
    // Pause/Resume controls
    // Note: Receiver auto-starts on launch, no manual start/stop needed
    if (receiver.isPaused()) {
        if (ImGui::Button("Resume", ImVec2(120, 30))) {
            receiver.resume();
        }
        ImGui::SameLine();
        ImGui::TextColored(ImVec4(1, 0.8f, 0, 1), "Paused");
    } else {
        if (ImGui::Button("Pause", ImVec2(120, 30))) {
            receiver.pause();
        }
        ImGui::SameLine();
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Active");
    }
    
    ImGui::SameLine();
    
    if (ImGui::Button("Reload Sunshine")) {
        sunshine.reload();
        
        // Update allowed_clients in config with Sunshine paired clients
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Paired with Sunshine");
        
        std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                    std::cout << "[Config] Auto-saved Sunshine client list" << std::endl;
            }
    }
    
    ImGui::SameLine();
    
    // Display Settings button  
    if (ImGui::Button("Display Settings")) {
        display_settings_gui.open();
    }
    
    
    // Render modal windows
    display_settings_gui.render(display_mgr);
    sunshine_settings_gui.render(sunshine, sunshine_webui, config);
    
    // About dialog
    if (ImGui::BeginPopupModal("About MoonMic", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("MoonMic v%s", MOONMIC_VERSION);
        ImGui::Separator();
        
        ImGui::Text("Real-time microphone streaming for PS Vita and other platforms");
        ImGui::Spacing();
        
        ImGui::Text("Author:");
        ImGui::SameLine();
        if (ImGui::SmallButton("AorsiniYT")) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://github.com/AorsiniYT", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://github.com/AorsiniYT &");
            #endif
        }
        
        ImGui::Text("GitHub:");
        ImGui::SameLine();
        if (ImGui::SmallButton("libmoonmic")) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://github.com/AorsiniYT/libmoonmic", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://github.com/AorsiniYT/libmoonmic &");
            #endif
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        // Donate button with distinctive color
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.3f, 0.3f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(1.0f, 0.4f, 0.4f, 1.0f));
        if (ImGui::Button("Donate on Ko-fi", ImVec2(200, 30))) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://ko-fi.com/aorsini", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://ko-fi.com/aorsini &");
            #endif
        }
        ImGui::PopStyleColor(2);
        
        ImGui::Spacing();
        if (ImGui::Button("Close", ImVec2(200, 0))) {
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    // Update notification dialog
    if (g_update_available && !g_update_dismissed) {
        ImGui::OpenPopup("Update Available");
    }
    
    if (ImGui::BeginPopupModal("Update Available", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("New Version Available!");
        ImGui::Separator();
        ImGui::Spacing();
        
        ImGui::Text("Current Version: %s", VersionChecker::getCurrentVersion().c_str());
        ImGui::Text("Latest Version:  %s", g_latest_version.c_str());
        ImGui::Spacing();
        
        ImGui::TextWrapped("A new version of MoonMic is available. Click Download to visit the releases page.");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        // Download button (green)
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.7f, 0.2f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.9f, 0.3f, 1.0f));
        if (ImGui::Button("Download", ImVec2(120, 30))) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", g_download_url.c_str(), NULL, NULL, SW_SHOWNORMAL);
            #else
            std::string cmd = "xdg-open " + g_download_url + " &";
            system(cmd.c_str());
            #endif
            g_update_dismissed = true;
            ImGui::CloseCurrentPopup();
        }
        ImGui::PopStyleColor(2);
        
        ImGui::SameLine();
        
        // Dismiss button
        if (ImGui::Button("Dismiss", ImVec2(120, 30))) {
            g_update_dismissed = true;
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    ImGui::End();
}

int main_gui(int argc, char* argv[]) {
    // Check for single instance
    SingleInstance single_instance("MoonMic host by AorsiniYT");
    if (single_instance.isAnotherInstanceRunning()) {
        std::cout << "[Main] Another instance is already running" << std::endl;
        single_instance.bringExistingToFront();
        return 0;
    }
    
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return 1;
    }
    
    // Create window
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(600, 650, "MoonMic host by AorsiniYT", NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create window" << std::endl;
        glfwTerminate();
        return 1;
    }
    
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);  // VSync
    
#ifdef _WIN32
    // Set window icon from embedded PNG resource (Windows only)
    HRSRC hResource = FindResourceA(NULL, "IDR_WINDOW_ICON_PNG", RT_RCDATA);
    if (hResource) {
        HGLOBAL hLoadedResource = LoadResource(NULL, hResource);
        if (hLoadedResource) {
            LPVOID pResourceData = LockResource(hLoadedResource);
            DWORD dwResourceSize = SizeofResource(NULL, hResource);
            
            if (pResourceData && dwResourceSize > 0) {
                int icon_width, icon_height, icon_channels;
                unsigned char* icon_pixels = stbi_load_from_memory(
                    (const unsigned char*)pResourceData, 
                    dwResourceSize, 
                    &icon_width, 
                    &icon_height, 
                    &icon_channels, 
                    4
                );
                
                if (icon_pixels) {
                    GLFWimage icon;
                    icon.width = icon_width;
                    icon.height = icon_height;
                    icon.pixels = icon_pixels;
                    
                    glfwSetWindowIcon(window, 1, &icon);
                    stbi_image_free(icon_pixels);
                    std::cout << "[Main] Window icon set successfully" << std::endl;
                } else {
                    std::cerr << "[Main] Failed to decode icon from resource" << std::endl;
                }
            }
        }
    } else {
        std::cerr << "[Main] Failed to find icon resource" << std::endl;
    }
#endif
    
    // Initialize ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    (void)io; // Silence unused warning
    
    ImGui::StyleColorsDark();
    
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 330");
    
    // Load configuration
    Config config;
    std::string config_path = Config::getDefaultConfigPath();
    if (!config.load(config_path)) {
        std::cerr << "[Config] Failed to load from: " << config_path << std::endl;
        std::cerr << "[Config] Using default configuration" << std::endl;
    } else {
        std::cout << "[Config] Loaded from: " << config_path << std::endl;
    }
    
#ifdef _WIN32
    // Launch guardian watchdog for crash recovery
    AudioDeviceManager deviceManager;
    AudioDeviceInfo currentDefault = deviceManager.getCurrentDefaultRecordingDevice();
    
    // If we have a physical mic and no original_mic_id set, save it
    if (!currentDefault.id.empty() && !currentDefault.is_virtual) {
        if (config.audio.original_mic_id.empty()) {
            config.audio.original_mic_id = currentDefault.id;
            config.save(config_path);
            std::cout << "[Main] Saved original microphone: " << currentDefault.name << std::endl;
        }
    }
    
    // Launch guardian if we have an original mic to restore
    if (!config.audio.original_mic_id.empty()) {
        if (GuardianLauncher::launchGuardian(config.audio.original_mic_id, currentDefault.name)) {
            std::cout << "[Main] Guardian watchdog activated" << std::endl;
        } else {
            std::cerr << "[Main] Warning: Guardian watchdog failed to start" << std::endl;
        }
    }
#endif
    // Create components
    AudioReceiver receiver;
    SunshineIntegration sunshine(config);
    SunshineWebUI sunshine_webui(config);
    DisplayManager display_mgr;
    DisplaySettingsGUI display_settings_gui;
    SunshineSettingsGUI sunshine_settings_gui;
    DebugGUI debug_gui;
    
    // Pass WebUI to receiver for resolution control
    receiver.setSunshineWebUI(&sunshine_webui);
    receiver.setDisplayManager(&display_mgr);
    
    // Hide console by default (show only in debug mode)
    DebugGUI::showConsole(g_debug_mode);
    
    // Auto-start receiver (always enabled - host is server mode)
    std::cout << "[Main] Starting receiver..." << std::endl;
    if (!receiver.start(config)) {
        std::cerr << "[Main] Failed to start receiver" << std::endl;
        // Continue anyway, user can retry with configuration changes
    }
    
    g_receiver = &receiver;
    
    // Check for updates (async, callback will set global flags)
    VersionChecker version_checker;
    version_checker.checkForUpdates([](const VersionChecker::VersionInfo& info) {
        g_update_check_done = true;
        if (info.update_available) {
            std::cout << "[VersionChecker] Update available: " << info.latest_version << std::endl;
            g_update_available = true;
            g_latest_version = info.latest_version;
            g_download_url = info.download_url;
        } else {
            std::cout << "[VersionChecker] No update available (current: " << info.current_version << ")" << std::endl;
        }
    });
    
    // Main loop
    while (!glfwWindowShouldClose(window) && g_running) {
        // Calculate states for power management
        // Note: We access previous frame stats here, which is fine
        auto temp_stats = receiver.getStats();
        bool is_active = temp_stats.is_receiving || g_debug_mode || g_update_available;
        
        if (glfwGetWindowAttrib(window, GLFW_ICONIFIED)) {
            // Minimized: Extremely low refresh (1Hz)
            glfwWaitEventsTimeout(1.0);
        } else if (is_active || debug_gui.isVisible()) {
            // Active (Streaming or Debugging): High refresh (Target 60Hz)
            // PollEvents prevents input lag, sleep yields CPU
            glfwPollEvents();
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        } else {
             // Idle (Standing by): Low refresh (~10Hz) to save power
             // Sufficient for status text updates
             glfwWaitEventsTimeout(0.1);
        }

        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        
        // Calculate delta time for animations
        static auto last_time = std::chrono::steady_clock::now();
        auto now = std::chrono::steady_clock::now();
        float delta_time = std::chrono::duration<float>(now - last_time).count();
        last_time = now;
        
        // Get current audio stats and convert to AudioStats
        auto receiver_stats = receiver.getStats();
        bool connected = !receiver_stats.last_sender_ip.empty();
        bool receiving = receiver_stats.is_receiving;
        
        // Convert to AudioStats for debug GUI
        AudioStats stats;
        stats.packets_received = receiver_stats.packets_received;
        stats.packets_dropped = receiver_stats.packets_dropped;
        stats.packets_dropped_lag = receiver_stats.packets_dropped_lag;
        stats.bytes_received = receiver_stats.bytes_received;
        stats.last_sender_ip = receiver_stats.last_sender_ip;
        stats.client_name = receiver_stats.client_name;
        stats.is_receiving = receiver_stats.is_receiving;
        stats.rtt_ms = receiver_stats.rtt_ms;
        
        // Update debug GUI (must be called every frame for animations)
        debug_gui.update(delta_time, stats, connected, receiving);
        
        renderGUI(window, receiver, sunshine, sunshine_webui, display_mgr, display_settings_gui, 
                   sunshine_settings_gui, debug_gui, config);
        
        // Render debug performance monitor window
        debug_gui.render();
        
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        
        glfwSwapBuffers(window);
    }
    
    // Cleanup
    receiver.stop();
    
#ifdef _WIN32
    // Disable driver on exit
    if (config.audio.auto_set_default_mic) {
        if (moonmic::platform::windows::IsRunningAsAdmin()) {
             // First restore default mic if currently on virtual
             // This is handled by receiver.stop() usually, but ensure it just in case
             if (!config.audio.original_mic_id.empty()) {
                 moonmic::platform::windows::SetDefaultRecordingDevice(config.audio.original_mic_id);
                 config.audio.original_mic_id = "";
                 config.save(Config::getDefaultConfigPath());
             }
           if (moonmic::platform::windows::IsRunningAsAdmin()) {
            std::cout << "[Main] Enabling Virtual Device Driver: " << config.audio.driver_device_name << std::endl;
            // Intenta habilitar el driver al inicio para que esté listo
            moonmic::platform::windows::ChangeDeviceState(config.audio.driver_device_name, true);
        }
            
            std::cout << "[Main] Disabling Virtual Device Driver..." << std::endl;
            moonmic::platform::windows::ChangeDeviceState(config.audio.driver_device_name, false);
        }
    }
#endif
    // Auto-save configuration on exit
    std::cout << "[Main] Saving configuration on exit..." << std::endl;
    config.save(config_path);
    
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    
    glfwDestroyWindow(window);
    glfwTerminate();
    
    return 0;
}

#endif // USE_IMGUI

int main_console(int argc, char* argv[]) {
    std::cout << "=== MoonMic Host ===" << std::endl;
    std::cout << "Version: " << MOONMIC_VERSION << std::endl << std::endl;
    
    // Check for --install-driver first
    for (int i = 1; i < argc; i++) {
        if (std::string(argv[i]) == "--install-driver") {
#ifdef _WIN32
            std::cout << "[Main] Installing VB-CABLE driver..." << std::endl;
            DriverInstaller installer;
            
            if (!DriverInstaller::isRunningAsAdmin()) {
                std::cout << "[Main] Requesting administrator privileges..." << std::endl;
                if (DriverInstaller::restartAsAdmin()) {
                    return 0; // Exit this instance, admin instance will run
                } else {
                    std::cerr << "[Main] Failed to restart as administrator" << std::endl;
                    return 1;
                }
            }
            
            if (installer.installVBCable()) {
                std::cout << "[Main] Driver installation completed" << std::endl;
                std::cout << "[Main] Please reboot your computer" << std::endl;
                return 0;
            } else {
                std::cerr << "[Main] Driver installation failed" << std::endl;
                return 1;
            }
#else
            std::cerr << "[Main] --install-driver is only supported on Windows" << std::endl;
            return 1;
#endif
        }
    }
    
    // Load configuration
    Config config;
    std::string config_path = Config::getDefaultConfigPath();
    
    // Check for --config and --debug arguments
    for (int i = 1; i < argc; i++) {
        if (std::string(argv[i]) == "--config" && i + 1 < argc) {
            config_path = argv[i + 1];
            i++;  // Skip next argument
        } else if (std::string(argv[i]) == "--debug") {
            g_debug_mode = true;
            std::cout << "[Main] Debug mode enabled (verbose logging)" << std::endl;
        }
    }
    
    if (!config.load(config_path)) {
        std::cout << "[Main] Using default configuration" << std::endl;
    }
    
    // Setup signal handler
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // Create audio receiver
    AudioReceiver receiver;
    g_receiver = &receiver;
    
    // Start receiver
    if (!receiver.start(config)) {
        std::cerr << "[Main] Failed to start receiver" << std::endl;
        return 1;
    }
    
    std::cout << "[Main] Press Ctrl+C to stop" << std::endl;
    
    // Main loop
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        // Print stats periodically
        auto stats = receiver.getStats();
        if (stats.is_receiving) {
            std::cout << "[Stats] Packets: " << stats.packets_received 
                      << " | Dropped: " << stats.packets_dropped
                      << " | From: " << stats.last_sender_ip << std::endl;
        }
    }
    
    receiver.stop();
    std::cout << "[Main] Shutdown complete" << std::endl;
    
    return 0;
}

int main(int argc, char* argv[]) {
    // Immediate output to verify program starts
    std::cout << "moonmic-host starting..." << std::endl;
    std::cout.flush();
    
    // Check for --debug flag
    for (int i = 1; i < argc; i++) {
        if (std::string(argv[i]) == "--debug") {
            g_debug_mode = true;
            break;
        }
    }

#ifdef _WIN32
    // Request Administrator privileges immediately
    if (!moonmic::DriverInstaller::isRunningAsAdmin()) {
        std::cout << "[Main] Administrator privileges required. Requesting elevation..." << std::endl;
        if (moonmic::DriverInstaller::restartAsAdmin()) {
            return 0; // Exit current instance, new one started
        } else {
            std::cerr << "[Main] Failed to restart as Administrator." << std::endl;
            std::cerr << "[Main] Please run this application as Administrator." << std::endl;
            return 1;
        }
    }
#endif
    
    try {
#ifdef USE_IMGUI
        // Check if --no-gui flag is present
        bool use_gui = true;
        for (int i = 1; i < argc; i++) {
            if (std::string(argv[i]) == "--no-gui") {
                use_gui = false;
                break;
            }
        }
        
        std::cout << "GUI mode: " << (use_gui ? "enabled" : "disabled") << std::endl;
        
        if (use_gui) {
            return main_gui(argc, argv);
        }
#endif
        
        return main_console(argc, argv);
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "Unknown fatal error occurred" << std::endl;
        return 1;
    }
}
