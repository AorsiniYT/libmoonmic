/**
 * @file main.cpp
 * @brief Main application entry point for moonmic-host
 */

#include "config.h"
#include "audio_receiver.h"
#include "sunshine_integration.h"
#include "display_manager.h"
#include "sunshine_settings_gui.h"
#include "sunshine_webui.h"
#include "display_settings_gui.h"
#include "single_instance.h"
#include "version_checker.h"
#include "debug_gui.h"
#include "version.h"  // Auto-generated by CMake
#include <iostream>
#include <csignal>
#include <thread>
#include <chrono>

#ifdef _WIN32
#include "platform/windows/driver_installer.h"
#endif

#ifdef USE_IMGUI
#include <imgui.h>
#include <imgui_impl_glfw.h>
#include <imgui_impl_opengl3.h>
#include <GLFW/glfw3.h>

// STB Image for loading window icon
#define STB_IMAGE_IMPLEMENTATION
#include "platform/windows/stb_image.h"
#endif

using namespace moonmic;

static bool g_running = true;
static AudioReceiver* g_receiver = nullptr;
bool g_debug_mode = false;  // Global debug flag (verbose logging) - non-static for external linkage

#ifdef USE_IMGUI
// Version update checker state
static bool g_update_available = false;
static bool g_update_check_done = false;
static bool g_update_dismissed = false;
static std::string g_latest_version;
static std::string g_download_url;
#endif

void signal_handler(int signal) {
    std::cout << "\n[Main] Shutting down..." << std::endl;
    g_running = false;
}

#ifdef USE_IMGUI

void renderGUI(GLFWwindow* window, AudioReceiver& receiver, SunshineIntegration& sunshine, 
               SunshineWebUI& sunshine_webui, DisplayManager& display_mgr, 
               DisplaySettingsGUI& display_settings_gui, SunshineSettingsGUI& sunshine_settings_gui,
               DebugGUI& debug_gui, Config& config) {
    // Make the ImGui window fill the entire GLFW window
    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(viewport->Pos);
    ImGui::SetNextWindowSize(viewport->Size);
    
    ImGuiWindowFlags window_flags = 0;
    window_flags |= ImGuiWindowFlags_NoTitleBar;
    window_flags |= ImGuiWindowFlags_NoCollapse;
    window_flags |= ImGuiWindowFlags_NoResize;
    window_flags |= ImGuiWindowFlags_NoMove;
    window_flags |= ImGuiWindowFlags_NoNavFocus;
    // Note: NoBringToFrontOnFocus removed to allow debug window to appear on top
    
    ImGui::Begin("MoonMic Host", nullptr, window_flags);
    
    // Title with About button on the right
    ImGui::Text("MoonMic host by AorsiniYT - v%s", MOONMIC_VERSION);
    ImGui::SameLine(ImGui::GetWindowWidth() - 80);  // Position to the right
    if (ImGui::SmallButton("About")) {
        ImGui::OpenPopup("About MoonMic");
    }
    ImGui::Separator();
    
    // Status
    ImGui::Text("Status: %s", receiver.isRunning() ? "Running" : "Stopped");
    ImGui::Separator();
    
#ifdef _WIN32
    // VB-CABLE Driver Status
    ImGui::Text("VB-CABLE Driver");
    DriverInstaller installer;
    bool vbcable_installed = installer.isVBCableInstalled();
    
    if (vbcable_installed) {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "[OK] VB-CABLE Installed");
        std::string input_device = installer.getVBCableInputDevice();
        std::string output_device = installer.getVBCableOutputDevice();
        if (!input_device.empty()) {
            ImGui::Text("  Input: %s", input_device.c_str());
        }
        if (!output_device.empty()) {
            ImGui::Text("  Output: %s", output_device.c_str());
        }
    } else {
        ImGui::TextColored(ImVec4(1, 0.5, 0, 1), "[!] VB-CABLE Not Installed");
        ImGui::TextWrapped("VB-CABLE virtual audio driver is required for audio routing.");
        ImGui::Spacing();
        
        if (ImGui::Button("Install VB-CABLE Driver", ImVec2(200, 30))) {
            if (!DriverInstaller::isRunningAsAdmin()) {
                ImGui::OpenPopup("Need Admin");
            } else {
                if (installer.installDriver()) {
                    ImGui::OpenPopup("Install Success");
                } else {
                    ImGui::OpenPopup("Install Failed");
                }
            }
        }
        
        // Admin privileges popup
        if (ImGui::BeginPopupModal("Need Admin", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
            ImGui::Text("Administrator privileges required.");
            ImGui::Text("The application will restart with admin rights.");
            ImGui::Separator();
            
            if (ImGui::Button("OK", ImVec2(120, 0))) {
                if (DriverInstaller::restartAsAdmin()) {
                    // Successfully restarted as admin, exit this instance
                    std::cout << "[Main] Restarting as admin, closing current instance..." << std::endl;
                    glfwSetWindowShouldClose(window, GLFW_TRUE);
                }
                ImGui::CloseCurrentPopup();
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0))) {
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }
        
        // Installation success popup
        if (ImGui::BeginPopupModal("Install Success", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
            ImGui::Text("VB-CABLE driver installed successfully!");
            ImGui::Text("Please reboot your computer to complete installation.");
            ImGui::Separator();
            
            if (ImGui::Button("OK", ImVec2(120, 0))) {
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }
        
        // Installation failed popup
        if (ImGui::BeginPopupModal("Install Failed", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
            ImGui::Text("Failed to install VB-CABLE driver.");
            ImGui::Text("Please check the console for error details.");
            ImGui::Separator();
            
            if (ImGui::Button("OK", ImVec2(120, 0))) {
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }
    }
    
    ImGui::Separator();
#endif
    
    // Sunshine Integration
    ImGui::Text("Sunshine Integration");
    
    if (sunshine.isPaired()) {
        // Sunshine is paired
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "[OK] Sunshine Paired");
        
        // Show Web UI login status
        if (sunshine_webui.isLoggedIn()) {
            ImGui::Text("Web UI: Logged in as %s", config.sunshine.webui_username.c_str());
            
            // Sunshine Settings button
            if (ImGui::Button("Sunshine Settings")) {
                sunshine_settings_gui.open();
            }
        } else {
            // Paired but not logged in
            ImGui::TextColored(ImVec4(1, 1, 0, 1), "Web UI: Not logged in");
            ImGui::TextWrapped("Login required for client validation & security");
            
            if (ImGui::Button("Login to Sunshine Web UI")) {
                ImGui::OpenPopup("Sunshine Web UI Login");
            }
            
            // Web UI login modal
            ImVec2 center = ImGui::GetMainViewport()->GetCenter();
            ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
            
            if (ImGui::BeginPopupModal("Sunshine Web UI Login", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
                ImGui::Text("Login to Sunshine Web UI");
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                static char webui_username[128] = "";
                static char webui_password[128] = "";
                static std::string login_error = "";
                
                ImGui::InputText("Username", webui_username, sizeof(webui_username));
                ImGui::InputText("Password", webui_password, sizeof(webui_password), ImGuiInputTextFlags_Password);
                
                if (!login_error.empty()) {
                    ImGui::Spacing();
                    ImGui::TextColored(ImVec4(1, 0, 0, 1), "%s", login_error.c_str());
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                if (ImGui::Button("Login", ImVec2(120, 0))) {
                    if (sunshine_webui.login(webui_username, webui_password)) {
                        login_error = "";
                        memset(webui_password, 0, sizeof(webui_password));
                        ImGui::CloseCurrentPopup();
                    } else {
                        login_error = "Invalid Sunshine credentials";
                    }
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Cancel", ImVec2(120, 0))) {
                    login_error = "";
                    ImGui::CloseCurrentPopup();
                }
                
                ImGui::EndPopup();
            }
        }
    } else {
        // NOTE: PIN-based pairing is currently DISABLED
        // Sunshine Web UI login provides more permissions and is the preferred method
        // PIN pairing code is preserved below for potential future reuse
        
        // Show message that Web UI login is required instead
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "[!] Sunshine Web UI Login Required");
        ImGui::TextWrapped("Please login to Sunshine Web UI to access full functionality.");
        ImGui::Spacing();
        if (ImGui::Button("Login to Sunshine Web UI")) {
            ImGui::OpenPopup("Sunshine Web UI Login");
        }
    }
    
    // Web UI Login Modal (outside if/else so it's accessible from both paths)
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    
    if (ImGui::BeginPopupModal("Sunshine Web UI Login", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Login to Sunshine Web UI");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        static char webui_username[128] = "";
        static char webui_password[128] = "";
        static std::string login_error = "";
        
        ImGui::InputText("Username", webui_username, sizeof(webui_username));
        ImGui::InputText("Password", webui_password, sizeof(webui_password), ImGuiInputTextFlags_Password);
        
        if (!login_error.empty()) {
            ImGui::Spacing();
            ImGui::TextColored(ImVec4(1, 0, 0, 1), "%s", login_error.c_str());
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        if (ImGui::Button("Login", ImVec2(120, 0))) {
            if (sunshine_webui.login(webui_username, webui_password)) {
                login_error = "";
                memset(webui_password, 0, sizeof(webui_password));
                ImGui::CloseCurrentPopup();
            } else {
                login_error = "Invalid Sunshine credentials";
            }
        }
        
        ImGui::SameLine();
        
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            login_error = "";
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    ImGui::Separator();
    
    // Status Indicators (simplified - LEDs instead of detailed stats)
    auto stats = receiver.getStats();
    bool connected = stats.is_connected;
    bool receiving = stats.is_receiving;
    bool paused = stats.is_paused;
    
    ImGui::Text("Status");
    debug_gui.drawStatusIndicators(connected, receiving, paused);
    
    // Show client info if connected
    if (connected) {
        ImGui::SameLine(ImGui::GetWindowWidth() - 200);
        if (!stats.client_name.empty()) {
            ImGui::TextColored(ImVec4(0.5f, 0.8f, 1.0f, 1.0f), "%s", stats.client_name.c_str());
        } else {
            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "%s", stats.last_sender_ip.c_str());
        }
    }
    
    ImGui::Separator();
    
    // Configuration (editable)
    ImGui::Text("Configuration");
    
    bool config_changed = false;
    
    // Port input
    int prev_port = config.server.port;
    if (ImGui::InputInt("Port", &config.server.port, 0, 0)) {
        if (config.server.port < 1 || config.server.port > 65535) {
            config.server.port = prev_port;  // Revert invalid value
        } else if (config.server.port != prev_port) {
            config_changed = true;
        }
    }
    
    // Output Sample Rate for VB-Cable
    int prev_resampling_rate = config.audio.resampling_rate;
    if (ImGui::InputInt("Output Sample Rate (Hz)", &config.audio.resampling_rate, 0, 0)) {
        // Common valid sample rates: 8000, 16000, 24000, 48000
        if (config.audio.resampling_rate < 8000 || config.audio.resampling_rate > 48000) {
            config.audio.resampling_rate = prev_resampling_rate;  // Revert invalid value
        } else if (config.audio.resampling_rate != prev_resampling_rate) {
            config_changed = true;
        }
    }
    ImGui::TextWrapped("Set to 16000 for direct streaming (no resampling). Set to 48000 for higher quality with resampling.");
    
    // Channels input
    int prev_channels = config.audio.channels;
    if (ImGui::InputInt("Channels", &config.audio.channels, 0, 0)) {
        if (config.audio.channels < 1 || config.audio.channels > 2) {
            config.audio.channels = prev_channels;  // Revert invalid value
        } else if (config.audio.channels != prev_channels) {
            config_changed = true;
        }
    }
    
    // Auto-save if any config changed
    if (config_changed) {
        std::string config_path = Config::getDefaultConfigPath();
        if (config.save(config_path)) {
            std::cout << "[Config] Auto-saved configuration changes" << std::endl;
        }
    }
    
    // Whitelist checkbox with auto-save
    bool prev_whitelist = config.security.enable_whitelist;
    if (ImGui::Checkbox("Whitelist Enabled", &config.security.enable_whitelist)) {
        if (prev_whitelist != config.security.enable_whitelist) {
            // Configuration changed, auto-save
            std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                std::cout << "[Config] Auto-saved changes" << std::endl;
            }
        }
    }
    
    // Speaker Mode checkbox (for debugging)
    bool prev_speaker = config.audio.use_speaker_mode;
    if (ImGui::Checkbox("Speaker Mode (Debug)", &config.audio.use_speaker_mode)) {
        if (prev_speaker != config.audio.use_speaker_mode) {
            // Hot-swap audio output if receiver is running
            if (receiver.isRunning()) {
                receiver.switchAudioOutput(config.audio.use_speaker_mode);
            }
            
            std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                std::cout << "[Config] Auto-saved speaker mode: " 
                          << (config.audio.use_speaker_mode ? "ON (direct playback)" : "OFF (VB-Cable)") 
                          << std::endl;
            }
        }
    }
    if (config.audio.use_speaker_mode) {
        ImGui::TextColored(ImVec4(1, 0.8f, 0, 1), "Warning: Audio goes to speakers, NOT VB-Cable");
    } else {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Audio sent to VB-Cable (normal mode)");
    }
    
    // Debug Mode checkbox
    if (ImGui::Checkbox("Debug Mode (Verbose Logs)", &g_debug_mode)) {
        std::cout << "[Main] Debug mode: " << (g_debug_mode ? "ON" : "OFF") << std::endl;
        // Toggle console visibility with debug mode
        DebugGUI::showConsole(g_debug_mode);
    }
    ImGui::SameLine();
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1), "Shows console & detailed logs");
    
    // Performance Monitor button (only visible in debug mode)
    if (g_debug_mode) {
        if (ImGui::Button("Performance Monitor")) {
            debug_gui.toggle();
        }
        if (debug_gui.isVisible()) {
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 0.8f, 0.3f, 1), "[OPEN]");
        }
    }
    
    ImGui::Separator();
    
    // Controls
    if (receiver.isRunning()) {
        // Pause/Resume buttons (only when running)
        if (receiver.isPaused()) {
            if (ImGui::Button("Resume")) {
                receiver.resume();
            }
        } else {
            if (ImGui::Button("Pause")) {
                receiver.pause();
            }
        }
        ImGui::SameLine();
        if (ImGui::Button("Stop Receiver")) {
            receiver.stop();
        }
    } else {
        if (ImGui::Button("Start Receiver")) {
            receiver.start(config);
        }
    }
    
    ImGui::SameLine();
    
    if (ImGui::Button("Reload Sunshine")) {
        sunshine.reload();
        
        // Update allowed_clients in config with Sunshine paired clients
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Paired with Sunshine");
        
        std::string config_path = Config::getDefaultConfigPath();
            if (config.save(config_path)) {
                    std::cout << "[Config] Auto-saved Sunshine client list" << std::endl;
            }
    }
    
    ImGui::SameLine();
    
    // Display Settings button  
    if (ImGui::Button("Display Settings")) {
        display_settings_gui.open();
    }
    
    
    // Render modal windows
    display_settings_gui.render(display_mgr);
    sunshine_settings_gui.render(sunshine, sunshine_webui, config);
    
    // About dialog
    if (ImGui::BeginPopupModal("About MoonMic", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("MoonMic v%s", MOONMIC_VERSION);
        ImGui::Separator();
        
        ImGui::Text("Real-time microphone streaming for PS Vita and other platforms");
        ImGui::Spacing();
        
        ImGui::Text("Author:");
        ImGui::SameLine();
        if (ImGui::SmallButton("AorsiniYT")) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://github.com/AorsiniYT", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://github.com/AorsiniYT &");
            #endif
        }
        
        ImGui::Text("GitHub:");
        ImGui::SameLine();
        if (ImGui::SmallButton("libmoonmic")) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://github.com/AorsiniYT/libmoonmic", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://github.com/AorsiniYT/libmoonmic &");
            #endif
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        // Donate button with distinctive color
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.8f, 0.3f, 0.3f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(1.0f, 0.4f, 0.4f, 1.0f));
        if (ImGui::Button("Donate on Ko-fi", ImVec2(200, 30))) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", "https://ko-fi.com/aorsini", NULL, NULL, SW_SHOWNORMAL);
            #else
            system("xdg-open https://ko-fi.com/aorsini &");
            #endif
        }
        ImGui::PopStyleColor(2);
        
        ImGui::Spacing();
        if (ImGui::Button("Close", ImVec2(200, 0))) {
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    // Update notification dialog
    if (g_update_available && !g_update_dismissed) {
        ImGui::OpenPopup("Update Available");
    }
    
    if (ImGui::BeginPopupModal("Update Available", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("New Version Available!");
        ImGui::Separator();
        ImGui::Spacing();
        
        ImGui::Text("Current Version: %s", VersionChecker::getCurrentVersion().c_str());
        ImGui::Text("Latest Version:  %s", g_latest_version.c_str());
        ImGui::Spacing();
        
        ImGui::TextWrapped("A new version of MoonMic is available. Click Download to visit the releases page.");
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
        
        // Download button (green)
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.7f, 0.2f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.9f, 0.3f, 1.0f));
        if (ImGui::Button("Download", ImVec2(120, 30))) {
            #ifdef _WIN32
            ShellExecuteA(NULL, "open", g_download_url.c_str(), NULL, NULL, SW_SHOWNORMAL);
            #else
            std::string cmd = "xdg-open " + g_download_url + " &";
            system(cmd.c_str());
            #endif
            g_update_dismissed = true;
            ImGui::CloseCurrentPopup();
        }
        ImGui::PopStyleColor(2);
        
        ImGui::SameLine();
        
        // Dismiss button
        if (ImGui::Button("Dismiss", ImVec2(120, 30))) {
            g_update_dismissed = true;
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
    
    ImGui::End();
}

int main_gui(int argc, char* argv[]) {
    // Check for single instance
    SingleInstance single_instance("MoonMic host by AorsiniYT");
    if (single_instance.isAnotherInstanceRunning()) {
        std::cout << "[Main] Another instance is already running" << std::endl;
        single_instance.bringExistingToFront();
        return 0;
    }
    
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW" << std::endl;
        return 1;
    }
    
    // Create window
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(600, 600, "MoonMic host by AorsiniYT", NULL, NULL);
    if (!window) {
        std::cerr << "Failed to create window" << std::endl;
        glfwTerminate();
        return 1;
    }
    
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);  // VSync
    
#ifdef _WIN32
    // Set window icon from embedded PNG resource (Windows only)
    HRSRC hResource = FindResourceA(NULL, "IDR_WINDOW_ICON_PNG", RT_RCDATA);
    if (hResource) {
        HGLOBAL hLoadedResource = LoadResource(NULL, hResource);
        if (hLoadedResource) {
            LPVOID pResourceData = LockResource(hLoadedResource);
            DWORD dwResourceSize = SizeofResource(NULL, hResource);
            
            if (pResourceData && dwResourceSize > 0) {
                int icon_width, icon_height, icon_channels;
                unsigned char* icon_pixels = stbi_load_from_memory(
                    (const unsigned char*)pResourceData, 
                    dwResourceSize, 
                    &icon_width, 
                    &icon_height, 
                    &icon_channels, 
                    4
                );
                
                if (icon_pixels) {
                    GLFWimage icon;
                    icon.width = icon_width;
                    icon.height = icon_height;
                    icon.pixels = icon_pixels;
                    
                    glfwSetWindowIcon(window, 1, &icon);
                    stbi_image_free(icon_pixels);
                    std::cout << "[Main] Window icon set successfully" << std::endl;
                } else {
                    std::cerr << "[Main] Failed to decode icon from resource" << std::endl;
                }
            }
        }
    } else {
        std::cerr << "[Main] Failed to find icon resource" << std::endl;
    }
#endif
    
    // Initialize ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    (void)io; // Silence unused warning
    
    ImGui::StyleColorsDark();
    
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 330");
    
    // Load configuration
    Config config;
    std::string config_path = Config::getDefaultConfigPath();
    if (!config.load(config_path)) {
        std::cout << "[Main] Using default configuration" << std::endl;
    }
    
    // Create components
    AudioReceiver receiver;
    SunshineIntegration sunshine(config);
    SunshineWebUI sunshine_webui(config);
    DisplayManager display_mgr;
    DisplaySettingsGUI display_settings_gui;
    SunshineSettingsGUI sunshine_settings_gui;
    DebugGUI debug_gui;
    
    // Hide console by default (show only in debug mode)
    DebugGUI::showConsole(g_debug_mode);
    
    // Auto-start if configured
    if (config.gui.show_on_startup) {
        receiver.start(config);
    }
    
    g_receiver = &receiver;
    
    // Check for updates (async, callback will set global flags)
    VersionChecker version_checker;
    version_checker.checkForUpdates([](const VersionChecker::VersionInfo& info) {
        g_update_check_done = true;
        if (info.update_available) {
            std::cout << "[VersionChecker] Update available: " << info.latest_version << std::endl;
            g_update_available = true;
            g_latest_version = info.latest_version;
            g_download_url = info.download_url;
        } else {
            std::cout << "[VersionChecker] No update available (current: " << info.current_version << ")" << std::endl;
        }
    });
    
    // Main loop
    while (!glfwWindowShouldClose(window) && g_running) {
        glfwPollEvents();
        
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        
        // Calculate delta time for animations
        static auto last_time = std::chrono::steady_clock::now();
        auto now = std::chrono::steady_clock::now();
        float delta_time = std::chrono::duration<float>(now - last_time).count();
        last_time = now;
        
        // Get current audio stats and convert to AudioStats
        auto receiver_stats = receiver.getStats();
        bool connected = !receiver_stats.last_sender_ip.empty();
        bool receiving = receiver_stats.is_receiving;
        
        // Convert to AudioStats for debug GUI
        AudioStats stats;
        stats.packets_received = receiver_stats.packets_received;
        stats.packets_dropped = receiver_stats.packets_dropped;
        stats.bytes_received = receiver_stats.bytes_received;
        stats.last_sender_ip = receiver_stats.last_sender_ip;
        stats.client_name = receiver_stats.client_name;
        stats.is_receiving = receiver_stats.is_receiving;
        
        // Update debug GUI (must be called every frame for animations)
        debug_gui.update(delta_time, stats, connected, receiving);
        
        renderGUI(window, receiver, sunshine, sunshine_webui, display_mgr, display_settings_gui, sunshine_settings_gui, debug_gui, config);
        
        // Render debug performance monitor window
        debug_gui.render();
        
        ImGui::Render();
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        
        glfwSwapBuffers(window);
    }
    
    // Cleanup
    receiver.stop();
    
    // Auto-save configuration on exit
    std::cout << "[Main] Saving configuration on exit..." << std::endl;
    config.save(config_path);
    
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    
    glfwDestroyWindow(window);
    glfwTerminate();
    
    return 0;
}

#endif // USE_IMGUI

int main_console(int argc, char* argv[]) {
    std::cout << "=== MoonMic Host ===" << std::endl;
    std::cout << "Version: " << MOONMIC_VERSION << std::endl << std::endl;
    
    // Check for --install-driver first
    for (int i = 1; i < argc; i++) {
        if (std::string(argv[i]) == "--install-driver") {
#ifdef _WIN32
            std::cout << "[Main] Installing VB-CABLE driver..." << std::endl;
            DriverInstaller installer;
            
            if (!DriverInstaller::isRunningAsAdmin()) {
                std::cout << "[Main] Requesting administrator privileges..." << std::endl;
                if (DriverInstaller::restartAsAdmin()) {
                    return 0; // Exit this instance, admin instance will run
                } else {
                    std::cerr << "[Main] Failed to restart as administrator" << std::endl;
                    return 1;
                }
            }
            
            if (installer.installDriver()) {
                std::cout << "[Main] Driver installation completed" << std::endl;
                std::cout << "[Main] Please reboot your computer" << std::endl;
                return 0;
            } else {
                std::cerr << "[Main] Driver installation failed" << std::endl;
                return 1;
            }
#else
            std::cerr << "[Main] --install-driver is only supported on Windows" << std::endl;
            return 1;
#endif
        }
    }
    
    // Load configuration
    Config config;
    std::string config_path = Config::getDefaultConfigPath();
    
    // Check for --config and --debug arguments
    for (int i = 1; i < argc; i++) {
        if (std::string(argv[i]) == "--config" && i + 1 < argc) {
            config_path = argv[i + 1];
            i++;  // Skip next argument
        } else if (std::string(argv[i]) == "--debug") {
            g_debug_mode = true;
            std::cout << "[Main] Debug mode enabled (verbose logging)" << std::endl;
        }
    }
    
    if (!config.load(config_path)) {
        std::cout << "[Main] Using default configuration" << std::endl;
    }
    
    // Setup signal handler
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // Create audio receiver
    AudioReceiver receiver;
    g_receiver = &receiver;
    
    // Start receiver
    if (!receiver.start(config)) {
        std::cerr << "[Main] Failed to start receiver" << std::endl;
        return 1;
    }
    
    std::cout << "[Main] Press Ctrl+C to stop" << std::endl;
    
    // Main loop
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        // Print stats periodically
        auto stats = receiver.getStats();
        if (stats.is_receiving) {
            std::cout << "[Stats] Packets: " << stats.packets_received 
                      << " | Dropped: " << stats.packets_dropped
                      << " | From: " << stats.last_sender_ip << std::endl;
        }
    }
    
    receiver.stop();
    std::cout << "[Main] Shutdown complete" << std::endl;
    
    return 0;
}

int main(int argc, char* argv[]) {
    // Immediate output to verify program starts
    std::cout << "moonmic-host starting..." << std::endl;
    std::cout.flush();
    
    try {
#ifdef USE_IMGUI
        // Check if --no-gui flag is present
        bool use_gui = true;
        for (int i = 1; i < argc; i++) {
            if (std::string(argv[i]) == "--no-gui") {
                use_gui = false;
                break;
            }
        }
        
        std::cout << "GUI mode: " << (use_gui ? "enabled" : "disabled") << std::endl;
        
        if (use_gui) {
            return main_gui(argc, argv);
        }
#endif
        
        return main_console(argc, argv);
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "Unknown fatal error occurred" << std::endl;
        return 1;
    }
}
